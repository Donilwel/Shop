# Сервис по покупке мерча
## Автор: Маслов Данила Юрьевич
## вторая попытка (первый раз дошел до финального собеседования), тут я заметно окреп в навыках, да и ручек стало меньше. PS: Вся отсебятина и непонятные моменты я расписал в `Объяснение неочевидных решений` и `Бизнес-логика`. Хорошего прочтения.
## Задача:
Необходимо реализовать сервис, который позволит сотрудникам обмениваться монетками и приобретать на них мерч.

# Стек
- Postgres
- GOlang, включая библиотеки `gorilla/mux` , `gorm.io/gorm`
- Redis
- логирование с помощью пакета `logrus`
- docker-compose
- Docker
- Swagger

### Объяснение неочевидных решений
- Что-то по поводу авторизации не понял. Но сделал я следующим образом: если пользователь хочет войти в несуществующий аккаунт: то он создается автоматически c выплевыванием JWT токена. Ну а если пользователь существует я выбрасываю JWT-токен.
- Также написал ручку по логауту, которая активный токен закидывает в базу данных Черного списка. Если человек попробует залогиниться с помощью этого токена, его попросят перезайти.
- Пользователь не может создать на свою почту 2 или более аккаунтов - сервис потребует пароль от существующего аккаунта.
- Смотря на Swagger файл, который дан в примере, он регистрацию проводит по Username и Password, что выглядит довольно скучно. Я решил, что будет круто, если при авторизации генерировать никнейм (количество комбинаций из 2 массивов должно хватить на сверх больше, чем 100000 человек, учел этот момент) а формат ввода это емейл и пароль.
- Также забавно, что товаров бесконечное количество, это немного странно, но ок, ничего тут не менял
- Долго сидел и думал по поводу того, какого типа информацию выплевывать когда делается запрос к info. В прошлом отборе я увидел, что UUID.uuid показывается в swagger'e как string. Ну и тут я думал, что айтемы выводить надо в UUID.uuid. Но в последний момент решил все же выводить также как и в файлике, потом на тех собесе интересно узнать: а можно ли было сделать по-своему.
- Сделал суперюзера, который в случае чего денег может накинуть людям, а также добавить мерч.
- Также написал ручку, которая показывает всех пользователей (чтобы сотрудник мог найти другого по нику и отблагодарить).


### Бизнес-логика

Необходимо реализовать сервис, который позволит сотрудникам обмениваться монетками и приобретать на них мерч. Каждый сотрудник должен иметь возможность видеть:
- Список купленных им мерчовых товаров
- Сгруппированную информацию о перемещении монеток в его кошельке, включая:
- Кто ему передавал монетки и в каком количестве
- Кому сотрудник передавал монетки и в каком количестве
- Количество монеток не может быть отрицательным, запрещено уходить в минус при операциях с монетками.
  Создана админ панель для добавления мерча или добавления монеток в кошелек пользователям (у него оно безлимитное количество)
- Чтобы зайти в режим админа, нужно ввести в `email`: `admin@admin` и в `password`: `admin`

#### Мерч — это продукт, который можно купить за монетки. Всего в магазине доступно 10 видов мерча. Каждый товар имеет уникальное название и цену. Ниже приведён список наименований и их цены.

## Далее пойдут базовые вещи в формате: Название:Цена
- t-shirt:80
- cup:20
- book:50
- pen:10
- powerbank:200
- hoody:300
- umbrella:200
- socks:10
- wallet:50
- pink-hoody:500

### Предполагается, что в магазине бесконечный запас каждого вида мерча. 

#### Доступные действия при авторизации:

- **Создание**:
- Пользователь будет создан
- Username генерируется рандомно
- Выплевывается JWT токен для логина
- Дается 1000 монет на старте
- Роль автоматически `EMPLOYEE_ROLE`

- **Авторизация**
- Выплевывается JWT токен для логина
- Пользователь войдет в аккаунт

- **Логаут**
- Активный JWT токен будет перемещен в черный список
- Пользователь выйдет из аккаунта


#### Доступные действия для сотрудника:

- **Информация о себе**:
  - JWT токен проверяется на корректность
  - Пользователю выбрасывается информация о монетах, переводах и полученных деньгах, а также о мерче, который был приобретен.

- **Получения списка Мерча**:
  - Выплевывается вся информация о мерче (ID, name, price)

- **Получение списка сотрудников**:
  - Выводится информация о сотрудниках, т.е. о пользователях, чья роль `EMPLOYEE_ROLE`. Выводится: ID, Username, Email.

- **Покупка товара**:
  - JWT токен проверяется на корректность
  - Вводится name мерча
  - Понижается остаток на кошельке, добавляется сотруднику новый купленный товар
  - Выводится ответ в формате: Остаток на балансе, Вещь которая была куплена и Никнейм сотрудника

- **Отправка монеток**:
  - JWT токен проверяется на корректность
  - Дальше вводится запрос в формате: кому и сколько
  - Создается новая транзакция
  - Меняется остаток на кошельке
  - У пользователя который напротив тоже добавляется новая транзакция
  - У получателя прибавляются деньги
  - Выводится соответсвующая транзакция в ответ


#### Доступные действия для админа

- **Получения списка Мерча**:
  - Выплевывается вся информация о мерче (ID, name, price)

  - **Получение списка сотрудников**:
  - Выводится информация о сотрудниках, т.е. о пользователях, чья роль `EMPLOYEE_ROLE`. Выводится: ID, Username, Email.

- **Отправка монеток**:
  - JWT токен проверяется на корректность
  - Дальше вводится запрос в формате: кому и сколько
  - У получателя прибавляются деньги
  - Выводится статус ОК

- **Создания мерча**:
  - JWT токен проверяется на корректность
  - Дальше вводится запрос в формате: тип мерча и его цена
  - Добавляется мерч
  - Выводится информация о добавленном мерче
- **Изменение цены мерча**:
  - JWT токен проверяется на корректность
  - Дальше вводится запрос в формате: тип мерча и его цена
  - Меняется цена мерча
  - Выводится информация о изменненом мерче


## Неочевидные условия


## Тестирование

### 1. Проверка доступности сервера
- **Эндпоинт:** GET /ping
- **Цель:** Убедиться, что сервер готов обрабатывать запросы.
- **Ожидаемый результат:** Статус код 200 и текст "ok".

```yaml
GET /api/ping

Response:

  200 OK

  Body: ok
```

### 2. Тестирование функциональности тендеров
#### Получение списка тендеров
- **Эндпоинт:** GET /tenders
- **Описание:** Возвращает список тендеров с возможностью фильтрации по типу услуг, если не будет передано тело serviceType - выведутся все тендеры.
- **Ожидаемый результат:** Статус код 200 и корректный список тендеров.
```yaml
GET /api/tenders?service_type="название типа сервиса"

Response:

  200 OK

  Body: [ 
    {
      ...
    }, 
    {
      ...
    }, 
    ... 
  ]
```

#### Создание нового тендера
- **Эндпоинт:** POST /tenders/new
- **Описание:** Создает новый тендер с заданными параметрами (нужно писать существующего пользователя который ответственен за организацию, но не является участником организации тендера куда пишется предложение).
- **Ожидаемый результат:** Статус код 200 и данные созданного тендера.

```yaml
POST /api/tenders/new

Request Body:

  {

    "name": "Тендер 1",

    "description": "Описание тендера",

    "serviceType": "Construction",

    "status": "CREATED",

    "organizationId": 1,

    "creatorUsername": "user1"

  }

Response:

  200 OK

  Body: 
  
  { 
    "id": 1, 
    "name": "Тендер 1", 
    "description": "Описание тендера",
    ...
  }
```



#### Откат версии тендера
- **Эндпоинт:** PUT /tenders/{tenderId}/rollback/{version}
- **Описание:** Откатить параметры тендера к указанной версии. (могут узнать только члены организации где был создан тендер.)
- Если в текущей версии статус тендера `CLOSE`то мы не сможем откатиться к прошлой версии, так как предложение было закрыто
- **Ожидаемый результат:** Статус код 200 и данные тендера на указанной версии.

```yaml
PUT /api/tenders/1/rollback/2?username=user1

Response:

  200 OK

  Body: 
  { 
    "id": 1, 
    "name": "Тендер 1 версия 2", 
    ... 
  }
```

### 3. Тестирование функциональности предложений
#### Создание нового предложения
- **Эндпоинт:** POST /bids/new
- **Описание:** Создает новое предложение для существующего тендера.
- **Ожидаемый результат:** Статус код 200 и данные созданного предложения.

# Структура проекта
Весь проект разбит на файлы.
### `cmd/server/`
По этому пути расположен файл `main.go`, который содержит в себе все [ручки] и все самое главное для правильной работы проекта.

### `config/`
По этому пути расположен файл `config.go`, в котором находится функция, запускающая все перенные из окружение, тем самым вызывая конфигурацию.

### `db/migrations/`
По этому пути расположен файл `tables_base.go`, в котором представлены таблицы для миграции (даны по условию `ТЗ`).

### `docs/`
По этому пути расположены файлы, которые отвечают за `Swagger`, для лучшего представления микросервиса.
### `handlers/`
По этому пути расположены файлы, которые отвечают за основную работу приложения (ручки).
- `bids.go` отвечает за описание всех действия, связанных с Предложениями.
- `ping.go` отвечает за базовую операцию при тестировании предложения `/api/ping`
- `tenders.go` отвечает за описание всех действий, связанных с Тендерами.

### `middleware/`
По этому пути расположен файл, который приписывает к каждому запросу `"Content-Type", "application/json"`, для представления данных в `json'e`.

### `models/`
По этому пути расположены все модели баз данных, которые созданы для миграции.

### `utils/`
По этому пути расположены файлы с быстрым переводом  `json'a` в читаемый вид (`JSONFormat.go`) и `database.go`. Этот файл отвечает за автомиграцию моделей, (которые расположены выше), с помощью фреймворка `gorm`.
### `validators/`
По этому пути расположен файл `Validate.go`, который отвечает за проверку при создании тендера (правильный ввод данных, правильная обработка их).

# Логирование:
- Производится с помощью пакета `logrus`
- Для проверки логов проследуйте к файлу (если он не создан то запустите просто приложение в контейнере) `logs/app.log`

# Параметры файла .env:

- SERVER_ADDRESS=0.0.0.0:8080
- POSTGRES_HOST=localhost
- POSTGRES_PORT=5432
- POSTGRES_USERNAME=postgres
- POSTGRES_PASSWORD=123456
- POSTGRES_DATABASE=shopdb
- POSTGRES_JDBC_URL=jdbc:postgresql://localhost:5432/shopsdb
- POSTGRES_CONN=postgres://postgres:123456@localhost:5432/shopsdb

# Swagger
- Локально показывает все верно, на всякий случай путь к `main` -> `cmd/main.go`.
- Для взаимодействия со Swagger'ом необходимо прописать `swag init -g (путь к main.go)`
- Для запуска используйте http://localhost:8080/swagger/index.html

# Linter configuration

- Для запуска используйте `golangci-lint run`

- errcheck – проверяет, обрабатываются ли ошибки.
- gosimple – выявляет упрощенные способы записи кода.
- govet – анализирует код и находит потенциальные ошибки.
- ineffassign – проверяет присвоение переменных, которые потом не используются.
- staticcheck – выявляет неэффективные и устаревшие конструкции.
- unused – обнаруживает неиспользуемые переменные, функции, константы.
- typecheck – проверяет правильность типов.
- gocyclo – измеряет сложность функций
- prealloc – предупреждает, если можно заранее выделить память для слайсов.

- настройка которая включает в себя
  - gocyclo: min-complexity: 15 – определяет, какие функции считать слишком сложными.
  - check-type-assertions: true – проверяет ошибки при приведении типов.
  - check-blank: true – запрещает игнорирование ошибок.
  - severity: warning – линтер будет выдавать предупреждения.
  - confidence: 0.8 – уровень уверенности (от 0 до 1), при котором линтер будет отмечать проблемы.
  - gofmt: simplify: true – включает упрощение кода.
- Директории которые не проверяются линтером: 
  - vendor – содержит внешние библиотеки
  - third_party – аналогично, сторонние зависимости.
- Кеширование
  - cache: enabled: true – включает кеширование, чтобы не проверять файлы, которые не изменились.
  - dir: ~/.cache/golangci-lint – путь к кешу.

# Версия приложения
Версия данного микросервиса - 1.0v. Все функции работают исправно, все ошибки отлавливаются.
 







